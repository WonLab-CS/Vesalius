% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/map_assays.R
\name{map_assays}
\alias{map_assays}
\title{Aling and integrate spatial assay from the same modality using super pixels}
\usage{
map_assays(
  seed_assay,
  query_assay,
  neighborhood = "knn",
  k = 20,
  radius = 0.05,
  depth = 1,
  dimensions = seq(1, 30),
  norm = "noise",
  mapping = "div",
  batch_size = 1000,
  signal = "variable_features",
  use_norm = "raw",
  custom_cost = NULL,
  overwrite = FALSE,
  merge = FALSE,
  verbose = TRUE
)
}
\arguments{
\item{seed_assay}{vesalius_assay object - data to be mapped to}

\item{query_assay}{vesalius_assay objecy - data to map}

\item{neighborhood}{character - how should the neighborhood be selected?
"knn", "radius", "depth" (See details)}

\item{k}{int ]2, n_points] number of neareset neighbors to be considered for
neighborhodd computation.}

\item{radius}{numeric ]0,1[ proportion of max distance between points 
to consider for the neighborhood}

\item{depth}{int [1, NA] graph depth from cell to consider from neighborhood
(See details)}

\item{dimensions}{Int vector containing latent space dimensions to use}

\item{mapping}{character string (div - exact) - mapping strategy.
Divide and conquer (approximate) or Exact mapping.}

\item{batch_size}{number of points per batch in query during assignment
problem solving}

\item{signal}{character (variable_features, all_features, embeddings, custom)
- What should  be used as cell signal to generate the cost matrix.
Seed details}

\item{use_norm}{character - which count data to use}

\item{custom_cost}{matrix - matrix of size n (query cells) by p (seed cells)
containing custom cost matrix. Used instead of vesalius cost matrix}

\item{overwrite}{logical - if custom_cost is not NULL, should this matrix
be added to the vesalius matrix or should it overwrite it completely.}

\item{verbose}{logical - should I be a noisy boy?}
}
\value{
vesalius_assay
}
\description{
Aling and integrate spatial assay from the same modality using super pixels
}
\details{
The goal is to assign the best matching point between a seed set and
a query set.

To do so, \code{integrate_horizontally} will first extract a
biological signal. This can be latent space embeddings per cell, or by using
gene counts (or any other modality).

If using gene counts, there are a few more options available to
you. First, you can select "variable_features" and vesalius will find the
intersection between the variable features in your seed_assay and your
query_assay. "all_features" will find the intersection of all genes across
assays (even if they are not highly variable). Finally, you can also select
a custom gene vector, containing only the gene set you are interested in.

The second step is to create a cost matrix. The cost matrix computes the
distance (using the signal) betwwen each point in the seed and query. It
also includes the distance in signal between each points neighborhoods.
The neighborhood singal is computed by averaging the signal across k
nearest neighbors in space if using Knn. If using radius, the neighborhood
will be computed using all cells within a definined radius. 
If using depth, coordinates will be used to create a voronoi graph. 
The neighborhood will be composed of all cells with "depth" steps i.e.
how many nodes in the graph do you need to go through to get to taget cell?
A depth of one will contain all cells in direct contact with center cell. 


This cost matrix is then parsed to a
Kuhnâ€“Munkres algorithm that will generate point pairs that minimize
the overall cost. 

Since the algorithm complexity is O(n3), it can be time consuming to
to run on larger data sets. We recomned using "exact" mapping when
there are less then 1500 points (a few minutes) and use "div" 
with larger data sets. The "div" option will split the query data
into random batches of pre-defined size (batch_size). The optimization
will be run on each batch serately and the results will be concatenated
together. Note this will not be an exact match but an approximation.

Finaly once the matches are found, the coordinates are mapped to its
corresponding point and a new object is returned.
}
